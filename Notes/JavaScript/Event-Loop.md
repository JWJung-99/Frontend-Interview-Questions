# 이벤트 루프란?

<br />

## 🕴🏼TL;DR

### 정의

이벤트 루프는 JavaScript가 싱글 스레드 언어임에도 불구하고 **비동기 작업을 처리할 수 있게 해주는**, 브라우저가 제공하는 메커니즘입니다. 이벤트 루프는 콜 스택과 태스크 큐를 반복적으로 확인하면서 콜 스택에 실행 중인 실행 컨텍스트가 없고, 태스크 큐에 대기 중인 작업이 존재한다면 태스크 큐에서 대기 중인 작업을 콜 스택에 푸시하여 실행합니다.

간단한 예로 `setTimeout(callback, 0)`이 있습니다.

1. `setTimeout(callback, 0)`을 호출하면, `setTimeout` 함수의 함수 실행 컨텍스트, Web API 타이머 함수의 함수 실행 컨텍스트가 콜 스택에 푸시됩니다.
2. 브라우저는 타이머를 설정하고, 타이머가 만료되면 콜백함수를 태스크 큐에 추가합니다.
3. 그 후 콜 스택이 비어 있는 시점에 이벤트 루프가 태스크 큐에서 대기 중인 `callback`을 꺼내서 실행합니다.

`setTimeout(callback, 0)`을 호출해도 현재 실행 중인 모든 동기 작업들이 완료된 후에야 그 콜백이 실행됩니다.

이처럼 이벤트 루프는 JavaScript의 비동기 작업을 처리하는 데 있어서 중요한 역할을 합니다. 이벤트 루프 덕분에 자바스크립트는 UI 업데이트나 사용자 입력 처리를 수행하면서도, 비동기 작업을 블로킹 없이 효율적으로 처리할 수 있습니다.

<br />

### 태스크 큐의 종류

태스크 큐는 매크로태스크 큐와 마이크로태스크 큐로 나뉩니다.

- **매크로태스크 큐**

  `setTimeout()`, `setInterval()` 같은 일반적인 비동기 작업들이 대기하는 큐입니다. 매크로태스크 큐의 작업은 **이벤트 루프가 콜 스택과 마이크로태스크 큐의 작업을 모두 처리한 후** 하나씩 처리합니다.
  
- **마이크로태스크 큐**

  `Promise.then()`과 같이 중요도가 높은 작업들이 대기하는 큐입니다. 마이크로태스크 큐는 매크로태스크 큐보다 우선순위가 높습니다. 이벤트 루프는 콜 스택이 비어있는 시점에 매크로태스크 큐의 작업을 실행하기 이전에 마이크로태스크 큐에 있는 모든 작업들을 먼저 처리합니다.  

<br />

|**매크로태스크 큐와 마이크로태스크 큐**|
|:---:|
|<img src="https://uploads.disquscdn.com/images/9466d8aa53fc5b3e63a92858a94bb429df02bbd20012b738f0461343beaa6f90.gif?w=320&h=172" />|

<br />

## 🔁 이벤트 루프

JavaScript의 특징 중 하나는 **싱글 스레드**로 동작한다는 것입니다. 싱글 스레드 방식은 한 번에 하나의 태스크만 처리할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹(작업 중단)이 발생합니다. 하지만 브라우저가 동작하는 것을 보면 많은 태스크가 동시에 처리되는 것처럼 느껴집니다.

|**동기 처리**|
|:---:|
|<img src="https://github.com/user-attachments/assets/26a6f897-2b00-4799-83f4-ae196b760393" />|

<br />

예를 들어, HTML 요소가 애니메이션 효과를 통해 움직이면서 이벤트를 처리하기도 하고 HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서 렌더링하기도 합니다. 이처럼 JavaScript의 동시성을 지원하는 것이 바로 **이벤트 루프**입니다.

이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나입니다. 구글의 V8 엔진을 비롯한 대부분의 JavaScript 엔진은 크게 2개의 영역으로 구분할 수 있습니다.

|**브라우저 환경**|
|:---:|
|<image src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lHHyfEhVB0LnQ3HlhSs8g.png" />|

- **콜 스택(Call Stack)**

  실행 컨텍스트 스택이 바로 콜 스택입니다. 함수를 호출하면 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행됩니다. JavaScript 엔진은 단 하나의 콜 스택을 사용하기 때문에 최상위 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행되지 않습니다.
  
- **힙(Heap)**

  객체가 저장되는 메모리 공간입니다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조합니다. 객체는 원시값과 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 동적으로 결정(할당)해야 합니다. 따라서 힙은 구조화되어 있지 않다는 특징이 있습니다.

<br />

이처럼 JavaScript 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이고, 비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 JavaScript 엔진을 구동하는 환경인 **브라우저**나 **Node.js**가 담당합니다. 이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공합니다.

- **(매크로) 태스크 큐**

  `setTimeout`이나 `setInterval` 같은 비동기 함수의 콜백함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역입니다. 태스크 큐와는 별도로 `Promise`의 후속 처리 메서드의 콜백함수가 일시적으로 보관되는 마이크로태스크 큐도 존재합니다.
  
- **이벤트 루프**

  이벤트 루프는 콜 스택에 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인합니다. 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시키며 이 때 콜 스택으로 이동한 함수는 실행됩니다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작합니다.

<br />

브라우저 환경에서 다음 코드가 어떻게 동작할까요?

```js
function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}

setTimeout(foo, 0);
bar();
```

1. 전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시됩니다.
2. 전역 코드가 실행되기 시작하여 `setTimeout` 함수가 호출됩니다. 이 때 `setTimeout` 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 됩니다. 브라우저의 Web API인 타이머 함수도 함수이므로 함수 실행 컨텍스트를 생성합니다.
3. `setTimeout` 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 팝 됩니다. 이때 타이머 설정과 타이머가 만료되면 콜백 함수를 태스크 큐에 푸시하는 것이 브라우저의 역할입니다.
4. 브라우저는 타이머를 설정하고 타이머의 만료를 기다립니다. 이후 타이머가 만료되면 **콜백함수 `foo`가 태스크 큐에 푸시되어 대기**하게 됩니다. `bar` 함수가 호출되어 `bar` 함수의 함수 길행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 됩니다. 이후 `bar` 함수가 종료되어 콜 스택에서 팝 됩니다. `foo` 함수는 아직 태스크 큐에서 대기 중입니다.
5. 전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜 스택에서 팝 됩니다. 이로서 콜 스택에는 아무런 실행 컨텍스트도 존재하지 않게 됩니다.
6. 이벤트 루프에 의해 콜 스택이 비어 있음이 감지되고 태스크 큐에서 대기 중인 콜백함수 `foo`가 이벤트 루프에 의해 콜 스택에 푸시됩니다. 즉, `foo` 함수가 호출되어 `foo` 함수의 함수 길행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 됩니다. 이후 `foo` 함수가 종료되어 콜 스택에서 팝 됩니다.

<br />

이처럼 비동기 함수인 `setTimeout`의 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면 비로소 콜 스택에 푸시되어 실행됩니다.

> [!WARNING]
>
> JavaScript는 싱글 스레드 방식으로 동작합니다. 이 때 싱글 스레드 방식으로 동작하는 것이 브라우저가 아니라 브라우저에 내장된 JavaScript 엔진이라는 것에 주의해야 합니다. **JavaScript 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작합니다.**

<br />

## 📖 참고

- 모던 JavaScript Deep Dive
- [How JavaScript Works?](https://medium.com/@zlatkov/how-does-javascript-actually-work-part-1-b0bacc073cf)
- [JavaScript Info - 마이크로태스크 큐](https://ko.javascript.info/microtask-queue)
