# 성능 최적화 방법

<br />

## 📝 메모이제이션

React에서 성능 최적화를 위해 여러 방법을 사용할 수 있는데, 그 중 대표적으로 메모이제이션이 있습니다. 메모이제이션은 **이전 값을 메모리에 저장해 동일한 계산의 반복을 제거해 빠른 처리를 가능하게 하는 기술**입니다. `React.memo`, `useCallback`, `useMemo`가 이 메모이제이션을 기반으로 동작합니다.

### `React.memo`

React의 `memo`를 사용하여 컴포넌트를 메모이제이션 할 수 있습니다. 이는 컴포넌트의 **props가 변경되지 않았을 때 리렌더링을 방지**하여 성능을 최적화합니다.

```jsx
const Button = ({ type, title, handleClick }) => {
  return (
    <button
      type={type}
      onClick={() => handleClick()}>
      {title}
    </button>
  );
};

export default memo(Button);
```

`React.memo`는 위와 같이 컴포넌트를 직접 감싸서 사용하며, props가 변경되지 않는다면 "Memoized" 된 내용을 재사용하므로 리렌더링이 발생하지 않습니다. `React.memo`는 props를 **얕은 비교**하는데, 원시 값의 경우 값이 같은지 확인하고, 객체나 배열은 주소값이 같은지 비교합니다.

<br />

**주의사항 - 부모가 전달하는 콜백함수**

위의 예시에서 한 가지 주의할 점이 있습니다. 예시의 `Button` 컴포넌트는 `React.memo`를 이용해 메모이제이션 된 상태입니다. 그렇다면 부모 컴포넌트에서 리렌더링이 발생할 때, `Button` 컴포넌트가 전달받는 props가 동일하다면 `Button` 컴포넌트의 리렌더링은 발생하지 않을까요?

정답은 X입니다! `Button` 컴포넌트는 부모 컴포넌트로부터 props로 `handleClick` 함수를 전달받고 있는데, 부모 컴포넌트에 정의한 `handleClick` 함수가 부모 컴포넌트의 리렌더링이 발생할 때마다 생성되어 새로운 참조값을 가지게 되어 `React.memo`가 `handleClick` prop을 이전과 다른 값으로 인지하기 때문입니다. 함수의 내용은 같은데 참조값이 달라져 `React.memo`가 메모이제이션에 불필요한 메모리를 낭비하고 있는 것입니다.

따라서 자식 컴포넌트에 전달하는 함수를 `useCallback`을 사용해 메모이제이션하여 컴포넌트가 리렌더링되어도 동일한 함수 인스턴스를 반환할 수 있도록 하면 `React.memo`가 정상적으로 동작할 것입니다.

<br />

### `useMemo`

`React.memo`가 컴포넌트를 메모이제이션하여 불필요한 리렌더링을 관리한다면, `useMemo`는 **함수의 계산 결과값을 메모이제이션**하여 불필요한 연산을 관리합니다.

만약 어떤 컴포넌트 내의 함수가 값을 반환하는데 많은 시간이 소요된다면, 이 컴포넌트가 리렌더링딜 때마다 함수를 호출하며 많은 시간이 소요될 것이고, 그 값을 하위 컴포넌트에서 사용한다면 함수 호출마다 새로운 값을 받아 리렌더링이 발생할 것입니다.

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

다음과 같이 `useMemo`는 첫 번째 인수인 함수의 반환값이 메모이제이션되며, 두 번째 인수인 의존성 배열의 요소가 변경될 때마다 첫 번째 인수인 함수를 다시 호출하여 반환값을 업데이트합니다. 의존성 배열의 요소가 변하지 않는다면 함수를 호출하지 않고 이전에 반환한 값을 재사용하여 함수 호출 시간도 절약하고 하위 컴포넌트의 리렌더링도 방지할 수 있게 됩니다.

<br />

### `useCallback`

`useMemo`가 함수의 계산 결과를 메모이제이션하여 불필요한 연산을 관리한다면, `useCallback`은 **함수 자체를 메모이제이션**합니다.

`React.memo`의 주의사항에서 확인할 수 있듯이 컴포넌트에 함수를 선언하면 컴포넌트가 리렌더링될 때마다 선언한 함수도 새로 생성됩니다. 이 함수를 하위 컴포넌트에 props로 전달한다면 하위 컴포넌트를 `React.memo`로 감쌌더라도 하위 컴포넌트 역시 계쏙해서 리렌더링이 발생할 것입니다. 그 이유는 **JavaScript의 함수는 객체라서, 새로 생성된 함수는 새로운 참조값을 가지기 때문**입니다.

```jsx
const memoizedValue = useCallback(computeExpensiveValue(a, b), [a, b]);
```

따라서 위와 같이 함수를 `useCallback`으로 메모이제이션하면, 의존성 배열의 요소들이 변하지 않는 이상 함수를 새로 생성하지 않고 하위 컴포넌트의 props에 동일한 참조값을 전달하여 하위 컴포넌트의 리렌더링을 방지할 수 있을 것입니다.

<br />

메모이제이션을 이용해 성능 최적화가 하지만 **무분별한 메모이제이션은 지양할 필요가 있습니다**. 메모이제이션을 위한 코드와 메모리가 추가로 필요하고, 최적화를 위한 연산이 불필요한 경우라면 불필요한 비용만 발생하기 때문입니다.

<br />

## 🖖🏻 코드 스플리팅

코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드하게 하여 초기 로드 시간을 줄입니다. `React.lazy`와 `Suspense`를 사용해 동적으로 컴포넌트를 로드할 수 있습니다.

코드 스플리팅은 다음과 같은 경우에 사용할 수 있습니다.

첫째, **초기 로딩 시간이 길어지는 경우**입니다. 애플리케이션이 커지면 초기 로딩에 모든 코드를 로드하는 것이 비효율적일 수 있습니다. 따라서 코드 스플리팅을 사용해 초기 로딩 시에는 필요한 핵심 코드만 로드하고 이후 추가적인 기능은 필요할 때 로드하도록 하여 초기 로딩 속도를 개선할 수 있습니다.

둘째, **라우트별 코드 분할이 필요한 경우**입니다. Single Page Application에서는 각 페이지가 별도의 기능과 UI를 가지므로 라우트별로 필요한 코드만 분리하여 로드할 수 있습니다. 이 방식은 `React.lazy`와 `Suspense`를 사용해 라우트별 컴포넌트를 동적으로 불러올 때 유용합니다.

<br />

## 📖 참고

- [React 최적화, useMemo, useCallback, React.memo](https://ssangq.netlify.app/posts/react-memo-useMemo-useCallback)
- [렌더링 성능 최적화하는 7가지 방법](https://velog.io/@shin6403/React-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%8A%94-7%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95-Hooks-%EA%B8%B0%EC%A4%80)
